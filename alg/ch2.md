# 贪心

贪心是一种思想，学会了这种思想可以虽然不能让你得到更多的 money 但是它让你游刃有余的处理很多问题，从而得到更多的利益！而利益对于计算机来说就说更高的效率，更低的时空复杂度。

什么是贪心？ 

贪心就是朝着某个方向不断的优化，不断的前进，最终将某个问题优化到某种程度上达到改问题的最优解。贪心是一种比较简单的思想，选好方向无脑向前即可！那么贪心体现在什么问题上呢？怎么来解决问题的？

## 现实背景&题型

* 某一天（24小时），存在很多会议，这些会议的开始结束均不相同，如何安排这些会议使得尽可能多的会议被安排上？这是活动安排问题。
* 假如有一天你看到了很多不同品种的珍贵植物（可以切割），但是只背了一个书包，你可以随便拿，这个时候你肯定会思考如何在有限的背包中实现利益最大化？这是装载问题。
* 北京和海南之间存在很多条路（边）和城市（节点），怎么样才可以找到最短的路？这是最短路问题。
* 要在 北上广深 这几个城市间建立通信网络，如何在最节省经费的前提下建立起来？这是最小生成树问题。
* 哈夫曼编码问题

以上的这些问题都蕴含了同一个思想，贪心！那么如何用贪心来解决这些问题？

## 性质

一般而言贪心具备以下特点，如果具备那么可以用贪心思想来解决。

这些特点分别是**贪心选择**，**最优子结构**和**无后效应**。

**贪心选择：** 首先要选择合适的贪心选择方向，根据选择的方向将问题分解成一个个子问题，然后每一步都是当前的局部最优，步步逼近逐渐达到全局最优。

**无后效应：** 子问题间不会相互影响，因为存在多个子问题，但是解决这些问题的时候只能一步步来，如果解决完前面的问题了但是解决后面的时候又影响到了前面的问题，牵一发而动全身，那么肯定不行。无后效应就是说子问题与子问题间不会相互影响。例如你最近疯狂学习英语，但是没有花时间在数学上面导致的数学成绩的下滑，虽然暂时性的提高了英语成绩，但是显然影响到了数学成绩，所以不具备无后效应。

**最优子结构：** 问题的最优解中包含子问题的最优解，这是定义。例如北京到海南，求最短距离，假设必定经过郑州，那么求北京到海南的最短距离这个大问题就可以分解为从北京到郑州的最短距离加上郑州到海南的最短距离，即通过子问题的最优解就可以推出问题的最优解。

**总结：** 贪心选择的重点是方向也可以理解分解子问题。无后效应的重点是子问题与子问题间是相互不影响的。最优子结构则是通过子问题的最优解可以推出问题的最优解。

## 思考过程

其实写题的时候很简单：三步即可

* 输入数据
  * （如何存储？采用什么数据结构？）
* 确定方向然后排序
  * （采取什么样的贪心策略？）
* 迭代输出

# 题型总结

贪心的题型主要分为以下几种：活动安排问题，装载问题，最短路，最小生成树，哈夫曼编码。还有很多题目无法归类，但是贪心思想则是蕴含一种，而贪心更是作为一种思想搭建起了算法大厦的基石。

## 1.0 活动安排问题

题目背景：在一段时间内有很多不同的时间长度的会议，这些会议的起始结束时间都不同，如果会议相互冲突的话只能选择其中一个并且一段会议必须是完整不可中断的。求在这一整段时间内可以安排最多数量的会议。

思路：首先选择一个方向，也就是贪心选择，为了保证尽可能多的安排会议，那么肯定需要保证会议时间尽可能的短且结束的早。由此出现三种方向，按照开始时间早的会议进行逐步解决，按照会议时长短进行，按照结束时间早的进行。

* 若按照会议开始时间作为贪心策略，举一个极端情况，如果一个会议开始时间很早但是持续了一天，显然只能安排这一个会议。其他的会议虽然开始时间晚但是结束的也早，没有安排上，显然浪费了。
* 若按照会议总时长短的来升序排列，举一个极端情况，如果一个会议总时长非常短，但是在快结束的时候才开始，如果将这个会议放在一个开，前面的时间显然都浪费了并且后面的时间也不够容纳更多的会议了，也不合适。
* 若按照会议的结束时间作为贪心策略，会议结束快的显然开始也快，而时长也是较短的，显然结合了上述两者的优势。

所以，按照会议结束时间来排序，如果结束时间相同，开始时间晚的优先，为了不影响前面的会议。排序后再来判断每一个活动参与的情况。

### coding

首先思考会议的数据结构，采用一个数组 a 来存储这个会议，每一个会议都有开始结束两个属性。用 s e 来记录会议的开始和结束。

```cpp
struct tv{
    int s , e;
}a[110];
```

将数据输入，存入数组中。

```cpp
for (int i = 0; i < n; i++){
    cin >> a[i].s >> a[i].e;
}
```

调用库函数 sort 对其进行排序，按照会议结束时间升序排列，如果结束时间相同那么时间晚的优先。

```cpp
int cmp(tv a, tv b){
    return a.e == b.e ? a.s > b.s : a.e < b.e;
}
```

确定起始位置，采用一个变量 t 来记录第一个会议的结束时间，然后下一个会议与之比较，如果时间晚于前一个会议那么就说明可以安排！反之不行，然后迭代记录下来可以安排会议的个数，同时还应当将当前可以安排会议的结束时间在作用到变量 t 上，为了保证下一次比较的是上一次安排的会议的结束时间。最后输出可安排会议的个数即可。注意会议的个数是从 1 开始的，而不是 0 ，因为 第一个会议为了方便起始，已经默认安排上了，循环是从第二个会议开始比较的。

```cpp
sort(a , a + n, cmp); 
int ans = 1 , t;
t = a[0].e;
for (int i = 1; i < n; i++){
    if (a[i].s >= t) {
        ans ++;
        t = a[i].e;
    }
}
    cout << ans << endl;
```

测试题：

1. [VJ-HDU-2037](https://vjudge.net/problem/HDU-2037)

## 2.0 装载问题

背景：你背了一个书包去旅游，发现了一处上古圣地，此处有好多种珍贵植物，不同品种的植物价值不同体积也不同并且植物可以随便切割。有些植物价值高但是体积更大。如何将使用有限的背包装取最大价值的植物回去？

思路：我们的目的是最大化的价值，所以价值高，体积小的最好，也就是价值密度（价值/体积） 这个参数越大越好。所以这就是贪心策略，按照价值密度来降序排列，价值密度大的有限装入背包，然后不断迭代即可！

此处装载的物品可以分割，若不可分则是 0/1 背包，而贪心针对0/1背包问题只能达到局部最优得到近似解，无法得到最优解。这个问题后续会详解。此处记住即可！

按照重量升序，重量升序之后逐个判断装入。

### coding

1. 输入数据（如何存储？采用什么数据结构？）
2. 确定方向然后排序（采取什么样的贪心策略？）
3. 迭代输出

数据结构如下：采用一个数组 a 来存储背包中的物品，其中每一个物品存在三个属性 j / f / h 其中 j 代表 物品价值， f 代表物品体积，而 h 代表物品的价值密度也就是价值除以体积 （j/f） 。

```cpp
struct room{
    double j , f , h;
}a[MAXSIZE];
```

输入数据，将 n 个物品存入数组之中。

```cpp
for (int i = 0; i < n; i++){
    cin >> a[i].j >> a[i].f;
    a[i].h = a[i].j / a[i].f;
}
```
选择贪心策略，按照价值密度降序排列

```cpp
int cmp(room a , room b){
    return a.h > b.h;
}
```

对物品进行排序，设置一个变量 sum 来记录当前背包中物品的价值。其中 m 是背包的容量，每一次都需要判断这个物品能否装进背包中，如果物品体积太大那么肯定装不下去。反之装下去后 sum 就要计下装进来物品的价值，然后背包的体积减下去，因为这个物品装进去了。一旦物品装不下去，那就按照背包的体积，这个东西能装多少装多少，因为根据贪心策略当前物品是最有价值的。然后输出即可。

```cpp
sort(a , a + n,cmp);
double sum = 0 ;
for (int i = 0; i < n; i++){
    if(a[i].f <= m){
        sum += a[i].j;
        m -= a[i].f;
    }else{
        sum += a[i].h * m;
        break;
    }
}
    cout << sum << endl;
```

1. [VJ-HDU-1009](https://vjudge.net/problem/HDU-1009) 这道题就是模板题，很简单。

2. [VJ-HDU-2111](https://vjudge.net/problem/HDU-2111) 这道题变形了一下，仔细看题，也是模板题。

## 3.0 end

最小生成树和最短路里面涉及到的部分比较多，放在的图论中总结。

贪心是一个比较简单算法思想，每一步都是最优解然后实现全局最优，但是现实中有很多问题往往会陷入局部最优。就像人生，每一步都选择最好的但最好结果却并不一定达到本应该达到的境界。

## 参考

1. [算法导论]
2. [趣学算法]
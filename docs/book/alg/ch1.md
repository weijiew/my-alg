# 时间复杂度推算

在写题时，题目中往往不会直接声明**时间复杂度**的限制。

但是可以根据**数据规模**和**时间限制**来推算时间复杂度。

如下图，注意单位。 $1s = 1000 ms$ 。

![20200816174359](https://cdn.jsdelivr.net/gh/weijiew/pic@master/images/20200816174359.png)

确定了时间复杂度后就可以保证算法不会超时。

在实际使用中常常都是估算，而且算法常常是以运行次数来估计的，例如 for 循环，循环 $10^8$ 次，也就是一亿次所消耗的时间大约为 $0.164s$。 当运行 $10^9$ 次时消耗的时间为 $1.64s$ 。

可以以此为参考，$10^8$ 是在时间复杂度 $O(n)$ 中运行时间不会超过 1s 。

所以一旦题目中给了限定条件，例如时间不超过 1s (1000 ms) 那么就说明这个算法运行的次数超过 $10^8$ 就有超时的风险。如果以指数为单位的话，在 1s 内执行 $10^8$ 次就是时间复杂度为 $O(N)$ 算法的上界。

如果这个算法所给的数据为 1000，而时间复杂度为 $O(N^2)$ ，那么对于 for 循环而言，循环 $1000\times10000=10^8$ 次是不会超时的。 

例如 HDU 的 [1425](http://acm.hdu.edu.cn/showproblem.php?pid=1425)，这是一个排序的题目。

题中所给的时间复杂度为 1000 MS 也就是 1s ，而题中所给的 n 为 1000000 。 

显然如果采用时间复杂度为 $N^2$的冒泡排序，粗略的来算，运行次数也是大于 $10^6\times\10^6 = 10^12$ 次的。肯定大于 1s ,必定超时。

如果采用时间复杂度为 $nlog2^{n^2}$ 的快速排序来来计算时间复杂度，最终消耗的时间为 600MS ，可以通过。


# 知识记录

1. fabs(-1.02) = 1.02 , abs(-1.02) = 1 , 二者都可以返回绝对值，但后者（abs）会取整。
2. int gcd(int x, int y) { return gcd(y,x%y);}
3.  取整函数：
 ceil(1.499) = 2;有余数，整数加一，不小于这个数的整数。double型
 floor(1.499)=1;有余数就抹掉，不大于这个数的整数。
 round(1.499)=1;四舍五入

## 代码规范

下面的代表规范大部分是针对 C/C++ 提出的，仅供参考。

* c/c++ 使用万能的头文件 `#include <bits/stdc++.h>` 这个头文件基本上支持了可以替代所有的头文件。注意可能在有的 OJ 上会报错，例如 POJ，但是大部分的 OJ 都能通过。
* 不要使用 C 风格的头文件，例如 `#include <stdio.h>`
* 输入判断结尾不要使用 `while(scanf("%d",&a) != EOF )` ，而用 `while(~scanf("%d",&a))` 。 EOF 代表 -1 ，也就是表明文件结束，而 `~` 则表示取反，而 `~-1 = 0` 也就是一旦扫描到 EOF ，则表示 `~scanf() = 0` 也就是循环结束。如果想设置具体
* 换行采用 K&C 风格，也就是左大括号不换行，右大括号单列一行。
* 变量有限在变量被调用的地方定义，例如：

```cpp
for (int i = 0; i < 10; i++) {
    int k = 10;
}
```
* 最好不要用宏，宏定义和宏函数容易出问题。应该采用 `const int MAX = 100005;` 而宏函数应当写成普通函数。
* 不要用 `#define` 定义常量，而用 `const int MAX = 1000005` 定义常量。 
* 常量名应该全部大写。
* 数组如果比较大，需要放在 main() 函数外部，作为全局变量，因为在 main() 内部使用的是栈空间，占用空间太大会导致栈溢出！
* 如果题目已经给出数据范围，那么直接用数组会比较快，不要用包装的容器。例如： stack,queue.
* 判断数据大小不要用  `a == b` ，应使用 `fabs(a - b) < 1e-9`，1e-9 视情况而定，因为二进制对小数的处理存在缺陷。
* 判断整数是否为奇数时 用 `x%2 != 0` 因为 `x%2 == 1` x 可能是负数，负数无奇偶之分。
* char 的范围可能为负，统计频次时注意负数，

# 二分

```cpp
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0, right = nums.size() - 1; 
  while(left <= right){ // 不加等号 [5] 5 这种类型得数据无法通过！！！
      // 防止数据溢出
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```
# 参考

[1]. [acm-cheat-sheet](https://github.com/soulmachine/acm-cheat-sheet)
[2]. [《算法竞赛入门到进阶》](https://book.douban.com/subject/34465629/)